---
title: 算法与数据结构面试题汇总
date: 2020-03-17 16:27:49
tags:
categories: 求职
---

## 堆排序算法的时间复杂度

**堆排序与快速排序、归并排序一样都是时间复杂度为O(N*logN)的几种常见排序方法。**

### [堆和堆排序](https://blog.csdn.net/MoreWindows/article/details/6709644)

```java
/**
 * @program:datastructureimpl
 * @description:堆接口
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-03-17 16:48
 **/
public interface Heap {
    public boolean insert(int o);
    public void delete();
    public int get() throws Exception;
    public void sort(int[] nums);//最小堆得到的是递减数组
}

/**
 * @program:datastructureimpl
 * @description:小顶堆实现 简约实现，不支持扩容，具体扩容实现参考PriorityQueue
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-03-17 17:03
 **/
public class MinHeap implements Heap{
    private int capacity=20;
    private volatile int[] nums;
    private volatile int index;

    public MinHeap(int[] nums) {
        this.nums = nums;
        this.capacity=nums.length;
        this.nums=new int[capacity];
        this.index=nums.length-1;
        for(int i=0;i<index+1;i++){
            this.nums[i]=nums[i];
        }
        init();
    }

    public MinHeap(int capacity) {
        this.capacity = capacity;
        this.nums=new int[capacity];
        this.index=-1;
    }

    public MinHeap(int capacity, int[] nums) {
        this.capacity = capacity;
        //如果nums长度大于capacity则放弃超过部分
        this.index=(capacity>=nums.length)?nums.length-1:capacity-1;
        this.nums=new int[capacity];
        for(int i=0;i<index+1;i++){
            this.nums[i]=nums[i];
        }
        init();

    }

    /**
    * @Description: 堆化数组
    * @Param: []
    * @return: void
    * @thorws:
    * @Author: Mr.Wang
    * @Date: 2020/3/17
    */
    private void init(){
        if(index<1){
            return ;
        }
        for(int i=(index+1)/2-1;i>=0;i--){
            fixDown(nums,i,index+1);
        }
    }

    /**
    * @Description:
    * @Param: [o]
    * @return: boolean
    * @thorws:
    * @Author: Mr.Wang
    * @Date: 2020/3/17
    */
    @Override
    public boolean insert(int o) {
        if(index==capacity-1){
            return false;//添加失败
        }
        nums[++index]=o;
        fixUp(nums,index);
        return true;
    }


    /**
    * @Description: 向上调整堆
     *      * 每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，
     *      * 现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中
    * @Param: [nums, index]
    * @return: void
    * @thorws:
    * @Author: Mr.Wang
    * @Date: 2020/3/17
    */
    private void fixUp(int[] nums,int i){
        int o=nums[i];
        int j=(i-1)/2;//父节点下标
        while(j>=0&&i!=0){
            if(nums[j]<=o){
                break;
            }
            nums[i]=nums[j];
            i=j;
            j=(i-1)/2;
        }
        nums[i]=o;
    }

    @Override
    public void delete() {
        if(index==-1){
            return ;
        }
        if(index==0){
            nums[0]=0;
            index--;
            return ;
        }
        swap(nums,0,index);
        index--;
        fixDown(nums,0,index+1);
    }

    private void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }

    /**
    * @Description: 向下调整
    * @Param: [nums, i, n] n为节点总数 i为从i节点开始调整
    * @return: void
    * @thorws:
    * @Author: Mr.Wang
    * @Date: 2020/3/17
    */
    private void fixDown(int[] nums,int i,int n){
        int o=nums[i];
        int j=i*2+1;//左子节点
        while(j<n){
            if(j+1<n&&nums[j+1]<nums[j]){
                j++;//这步很妙，选取出了左右子节点中较小值
            }
            if(o<=nums[j]){
                break;//父节点均小于左右子节点，则不需要调整
            }
            nums[i]=nums[j];
            i=j;
            j=i*2+1;
        }
        nums[i]=o;
    }

    public void print(){
        for(int i=0;i<=index;i++){
            System.out.print(nums[i]);
            System.out.print(" ");
        }
        System.out.println("");
    }

    public void print(int[] nums){
        for(int i=0;i<nums.length;i++){
            System.out.print(nums[i]);
            System.out.print(" ");
        }
        System.out.println("");
    }

    @Override
    public int get() throws Exception{
        if(index==-1){
            throw new Exception("堆中无元素");
        }
        return nums[0];
    }

    /**
    * @Description: 利用最小堆进行排序得到的是递减数组
    * @Param: [nums]
    * @return: void
    * @thorws:
    * @Author: Mr.Wang
    * @Date: 2020/3/17
    */
    @Override
    public void sort(int[] nums) {
        //先堆化数组
        for(int i=nums.length/2-1;i>=0;i--){
            fixDown(nums,i,nums.length);
        }
        print(nums);
        //交换nums[0]与nums[i]
        for(int i=nums.length-1;i>=1;i--){
            swap(nums,0,i);
            fixDown(nums,0,i);
        }
    }
}
```


## Iterator实现

### Iterator接口

```java
/**
 * @program:datastructure
 * @description:
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2019-12-17 15:35
 **/
public interface Iterator {
    public boolean hasNext();
    public Object next();
}

/**
 * @program:datastructure
 * @description:
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2019-12-17 15:36
 **/
public interface Container {
    public Iterator getIterator();
}
```

### 具体实现
```java
/**
 * @program:datastructure
 * @description:
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2019-12-17 15:37
 **/
public class NameRepository implements Container {

    private String[] name={"tingting","huanhuan","dog","cat"};
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator{
        private int index=0;
        public boolean hasNext() {
            if(index<name.length){
                return true;
            }
            return false;
        }

        public Object next() {
            if(this.hasNext()){
//                String ret= name[index];
////                index++;
////                return ret;
                return name[index++];
            }
            return null;
        }
    }
}

```



