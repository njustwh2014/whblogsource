---
title: 设计模式题汇总
date: 2020-03-13 20:56:00
tags: 
    - 设计模式
categories: 求职
---

## 设计原则有哪些？

+ 单一职责原则：让类或接口职责单一
+ 里氏替换原则：子类去替换父类，做到通用编程
+ 依赖倒置原则：面向接口编程
+ 接口隔离原则：接口的设计要精简单一
+ 迪米特法则：最少知识原则，降低依赖间的耦合
+ 开闭原则：对扩展开放，对修改关闭

## 创建型

### 单例模式

+ 懒汉式（线程安全问题）
+ 饿汉式

### [**简单工厂模式**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.md)

### [**工厂方法**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.md)

定义一个创建对象的接口，但由子类决定实例化哪个类。工厂方法把实例化推迟到子类。

```java
public abstract class Factory{
    abstract public Product factoryMethod();
    public void doSomething(){
        Product product=factoryMethod();
        //do something with product
    }
}
```

```java
public class ConcreteFactory1 extends Factory{
    public Product factoryMethod(){
        return new ConcreteProduct1();
    }
}
```

```java
public class ConcreteFactory2 extends Factory{
    public Product factoryMethod(){
        return new ConcreteProduct2();
    }
}
```

### [**抽象工厂**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.md)

提供一个接口，用于创建**相关的对象家族**。

抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。

抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory中的createProductA()和createProductB()方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

至于创建对象的家族这一概念是在Client体现，Client要通过AbstractFactory同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client需要同时创建出这两个对象。

从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。

### [**生成器（Builder）**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%94%9F%E6%88%90%E5%99%A8.md)

封装一个对象的构造过程，并允许按步骤构造。

`java.lang.StringBuilder`

### [**原型模式(Prototype)**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.md)

使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。

## 行为型

### [**责任链**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%B4%A3%E4%BB%BB%E9%93%BE.md)

### [**命令**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%91%BD%E4%BB%A4.md)

看到这

### [**状态**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%8A%B6%E6%80%81.md)

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。

### [**策略**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AD%96%E7%95%A5.md)

定义一系列算法，封装每个算法，并使它们可以互换。

策略模式可以让算法独立于使用它的客户端。

**策略模式与状态模式的比较**

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。

状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。


## SpringBoot可以借鉴的设计模式

### 单例模式

单例模式，主要目的是保证实例的独一无二，提高资源的重复利用。单例模式的难点就在于需要通过代码来维护系统中实例的唯一性，需要确保各种线程不安全环境下实例的独一性。

常用于配置文件的读取，监控程序，IOC容器等，spring中最常用的单例实现方式就是注册登记式的单例模式，这个后面看源码的时候，会深入了解

一句话总结：保证独一无二

### 原型模式

原型模式其实就是针对复制而言的一种模式，原型模式中需要弄清**浅复制和深复制**的区别。

+ 浅复制：对于数据类型是基本数据类型的成员变量，浅复制直接进行值的传递，即将原始对象中属性的值复制一份给新对象；对于引用数据类型的成员变量，浅复制就只是传递引用，这样使得两个对象之间其实操作的是同一份数据
+ 深复制：就是在浅复制的基础上，完成对象引用的深层次的复制。深复制不仅要复制对象所有的基本数据类型，还要在复制过程中为原有的引用数据类型开辟新的存储空间，将引用对象的数据拷贝到新开辟的存储空间中。一定程度上来说，对象进行深复制就是要对整个对象图进行复制。

更为形象的图形解释可以参考这篇博客——深复制与浅复制的区别

**原型模式主要就是应用于对象间的复制。spring中我们在配置对象的scope的时候，将scope配置成为prototype，即将bean配置成多例的，其中就会用到原型模式。**

一句话总结：复制作用

### 代理模式

从总体来看代理模式的作用就是在某一个类中某一指定的方法执行之前和执行之后，织入一些增强逻辑，这个理解依旧有点绕，但是结合AOP来理解就不难了，AOP的主要作用就是在目标方法的执行前和执行后织入一些增强的逻辑。

代理通常分为**静态代理和动态代理**，由于静态代理在扩展性方面的不足才引出了动态代理。

> 引申：静态代理需要目标对象与代理对象均要实现同一接口，当接口添加新方法时，代理对象与目标对象都要实现该方法，从而导致扩展性不足。

动态代理的实现方式常见的有两种：**一种是JDK Proxy，另一种是CgLib**，前者是动态植入，后者是继承；前者要求目标类要实现一个接口，目的就是方便获取方法信息，方便JDK利用反射动态调用。使用JDK动态代理的时候，增强的逻辑类需要实现InvocationHandler接口，在其中的invoke方法中去编写增强逻辑。CGLib相对来说就容易的多，具体可以见上文。

**动态代理在spring中用的较多，典型的AOP就是用的代理。除此之外，结合实际来看，如果针对原有的目标需要动态进行增强都可以利用动态代理模式**

一句话总结：买票找黄牛，办事找代理。

### 策略模式

策略模式是比较好理解的一种设计模式，该模式就是封装了一些算法供用户选择，根据用户的选择如何确定到指定的算法策略的过程中，为了避免使用if...else或者switch这种选择语句，就需要结合工厂模式进行使用，因此策略模式一定程度上并不单独使用

**使用场景：支付方式的选择**

一句话总结：我走那条路，我做主

### 模板方法模式

模板方法模式也是一个比较好理解的设计模式，无非就是在估计的流程中，加入一些不同的算法实现，最终产生出不同的结果而已，**提供的模板一般采用抽象类来实现，需要加入自己的算法的时候，就通过继承这个抽象类来完成。**

**使用场景：JdbcTemplate，工作流，spring-orm**

一句话总结：流程标准化，原料自己加

### 委派模式

**委派模式某一种程度上是代理和策略模式的结合**，在实现过程中，最重要的就是对委派列表的维护，这在之前的博客中实现的比较简单，直接值委派者中维护了引用。

**使用场景：spring中的DispatcherServlet、Delegate命名结尾的都是委派模式**

一句话总结：项目经理委派活给普通员工

### 适配器模式

**适配器模式从命名来看也能理解其意思，需要和装饰者模式区分开来。**针对两者的区别还是列出一个类图吧。

![适配器模式与装饰者模式类图对比](设计模式题汇总/适配器模式与装饰者模式类图对比.png)

使用场景：DataAdapter

一句话总结：转换头

### 装饰者模式

一定程度上来讲，装饰者模式与适配器模式有点类似，两者的具体区别上面的图中已经很好的展示出来了

**使用场景：spring中以Decorate结尾的都是使用的装饰者模式，IO流的设计，数据源**

一句话总结：同宗同源的增强

### 观察者模式

只需要理清楚两个角色，**消息发布者和消息订阅者**，难点在于消息发布者如何维护多个消息订阅者的信息

**使用场景：消息队列，swing中的监听器，spring中的监听器**

一句话总结：完成时通知一下。
