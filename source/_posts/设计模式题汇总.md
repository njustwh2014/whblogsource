---
title: 设计模式题汇总
date: 2020-03-13 20:56:00
tags: 
    - 设计模式
categories: 求职
---

## 设计原则有哪些？

+ 单一职责原则：让类或接口职责单一
+ 里氏替换原则：子类去替换父类，做到通用编程
+ 依赖倒置原则：面向接口编程
+ 接口隔离原则：接口的设计要精简单一
+ 迪米特法则：最少知识原则，降低依赖间的耦合
+ 开闭原则：对扩展开放，对修改关闭

## 创建型

### 单例模式

+ 懒汉式（线程安全问题）
+ 饿汉式

### [**简单工厂模式**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.md)

### [**工厂方法**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.md)

定义一个创建对象的接口，但由子类决定实例化哪个类。工厂方法把实例化推迟到子类。

```java
public abstract class Factory{
    abstract public Product factoryMethod();
    public void doSomething(){
        Product product=factoryMethod();
        //do something with product
    }
}
```

```java
public class ConcreteFactory1 extends Factory{
    public Product factoryMethod(){
        return new ConcreteProduct1();
    }
}
```

```java
public class ConcreteFactory2 extends Factory{
    public Product factoryMethod(){
        return new ConcreteProduct2();
    }
}
```

### [**抽象工厂**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.md)

提供一个接口，用于创建**相关的对象家族**。

抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。

抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。

从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。

### [**生成器（Builder）**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%94%9F%E6%88%90%E5%99%A8.md)

封装一个对象的构造过程，并允许按步骤构造。

`java.lang.StringBuilder`

### [**原型模式(Prototype)**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.md)

使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。

## 行为型

### [**责任链**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%B4%A3%E4%BB%BB%E9%93%BE.md)

### [**命令**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%91%BD%E4%BB%A4.md)

看到这

### [**状态**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%8A%B6%E6%80%81.md)

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。

### [**策略**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AD%96%E7%95%A5.md)

定义一系列算法，封装每个算法，并使它们可以互换。

策略模式可以让算法独立于使用它的客户端。

**策略模式与状态模式的比较**

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。

状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。