---
title: 面试问题汇总
date: 2020-02-27 10:20:25
tags: 
    - Java 
    - Redis
    - Mysql
    - Vue
    - Springboot
categories: 求职
---

## Java

### 1.讲一下HashMap的原理，如果链表过长怎么办，如果想让Map按照put的顺序存放键值对应该使用什么类？

HashMap在存在hash冲突的情况下，会使用链表或红黑树存储hash冲突的key，一般当链表长度超过`TREEIFY_THRESHOLD`会将链表转成红黑树。

Map按照元素大小排序用TreeMap

Map按照元素put顺序用LinkedHashMap


### 2.Synchronized实现原理，原子操作实现原理

[参考文章](https://juejin.im/post/5cee325e6fb9a07ee85c0c49)

**jdk对synchronized做了哪些优化：**

+ 适应性自旋锁：为了减少线程状态的改变带来的消耗，不停地执行当前线程

+ 锁消除：对于不可能存在共享资源竞争的锁进行消除

+ 锁粗化：对于连续多次加锁，精简到只有一次。

+ 轻量级锁：无竞争条件下，通过CAS消除同步互斥

+ 偏向锁：无竞争条件下消除同步互斥，连CAS操作都不需要

原子操作实现原理：总线锁 缓存锁 CAS

那么**CAS不足之处**：

+ ABA

+ 循环时间长会导致消耗大

+ 只能保证一个共享变量原子操作


### 3.Spring Aop实现方式，还有其他的什么方式实现

AOP 面向切面编程，是对面向对象的补充，处理系统中各个模块的横切关注点，常用于事务管理、日志模块、缓存等。

AOP实现的关键在于AOP框架自动创建AOP代理，常有以AspectJ为代表的静态代理，和以SpringAop为代表的动态代理

SpringAop的实现方式主要有通过反射的JDK动态代理和CGLIB(Code Generation Library).

+ JDK动态代理：核心是`InvocationHandler`接口和`Proxy`类，目标类必须是个实现接口的类

+ CGLIB：对于没有实现接口的类，SpringAOP使用CGLIB来动态代理目标类，**注意CGLIB是通过继承来实现动态代理，对于final类不能通过CGLIB做动态代理**

**JDK动态代理示例**

```java
//一个接口

/**
 * @program:datastructureimpl
 * @description:服务接口
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-02-27 21:09
 **/
public interface Service {
    public void add(int num);
    public int search();
}

//接口对应实现类

/**
 * @program:datastructureimpl
 * @description:服务实现
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-02-27 21:11
 **/
public class ServiceImpl implements Service {
    private int num;

    public ServiceImpl(int num) {
        this.num = num;
    }

    @Override
    public void add(int num) {
        System.out.println("add...");
        this.num+=num;
    }

    @Override
    public int search() {
        return this.num;
    }
}

//InvocationHandler实现类 这里我类的名字拼错了


import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @program:datastructureimpl
 * @description:Invocation实现类
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-02-27 21:13
 **/
public class MyInnovacation implements InvocationHandler {
    private Object target;
    public MyInnovacation(Object o) {
        super();
        this.target=o;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //方法之前前操作
        System.out.println(method.getName()+"执行前");
        Object result=method.invoke(target,args);//注意不是proxy，不然会循环invoke
        //方法执行后操作
        System.out.println(method.getName()+"执行后");
        return result;
    }

    public static void main(String[] args) {
        Service service=new ServiceImpl(10);
        MyInnovacation myInnovacation=new MyInnovacation(service);
        Service proxyService= (Service) Proxy.newProxyInstance(service.getClass().getClassLoader(),service.getClass().getInterfaces(),myInnovacation);

        proxyService.add(10);

        proxyService.add(20);

        System.out.println("current num in target: "+(int)proxyService.search());
    }
}
```

**CGLib示例**

```java
//目标类 不需要实现统一接口
/**
 * @program:datastructureimpl
 * @description:未实现统一接口类
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-02-27 21:37
 **/
public class Base {
    private int num;

    public Base(int num) {
        this.num = num;
    }

    //cglib动态代理的目标类必须要有无参构造器
    public Base() {
        this.num=0;
    }

    public void add(int num){
        this.num+=num;
    }

    public int search(){
        return num;
    }
}

//实现动态代理类CglibProxy，需要实现MethodInterceptor接口的intercept方法。该代理中在add方法前后加入了自定义的切面逻辑，目标类add方法执行语句为proxy.invokeSuper(object, args);
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * @program:datastructureimpl
 * @description:cglib动态代理类
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-02-27 21:39
 **/
public class CglibProxy implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("before....");
        Object result=methodProxy.invokeSuper(o,args);
        System.out.println("after...");
        return result;
    }
}

//代理工厂类 用于获取增强后的目标类

import org.springframework.cglib.proxy.Enhancer;

/**
 * @program:datastructureimpl
 * @description:增强类的工厂类
 * @author: Huan Wang(https://github.com/njustwh2014)
 * @create:2020-02-27 21:50
 **/
public class CglibProxyFactory {

    /**
    * @Description: 获得增强后的目标类，也就是切入逻辑advice之后的目标类
    * @Param: [proxy]
    * @return: cn.edu.seu.wh.aop.cglib.proxy.Base
    * @thorws:
    * @Author: Mr.Wang
    * @Date: 2020/2/27
    */
    public static Base getInstance(CglibProxy proxy){
        Enhancer enhancer=new Enhancer();
        enhancer.setSuperclass(Base.class);
        //回调方法的参数为代理类对象CglibProxy，最后增强目标类调用的是代理类对象CglibProxy中的intercept方法
        enhancer.setCallback(proxy);
        //此刻已是增强后的目标类，继承于源目标类
        Base base=(Base)enhancer.create();
        return base;
    }

    public static void main(String[] args) {
        CglibProxy cglibProxy=new CglibProxy();
        //base为增强后的目标类
        Base base=CglibProxyFactory.getInstance(cglibProxy);
        base.add(10);
        base.search();
    }
}




```




### 4.JVM GC收集器特点

### 5.JVM双亲委派机制

### 6.Session

### 7.JDK1.8新特性

### 8.NIO原理

### 9.JVM 运行时数据区

## 网络通信

### 1.Http协议

### 2.XSS攻击，避免的方法

## 数据库

### 1.数据库索引，数据库乐观锁悲观锁

### 2.SQL注入原理

## 操作系统

### 1. linux熟悉吗

## 编程题

### 1. 二分查找

```java
/*
@nums 排序好的数组
@target
@return f返回目标下标 如果没有 返回-1
*/
public int binarySearch(int[] nums,int target){
    if(nums==null||nums.length==0){
        return -1;
    }
    int left=0,right=nums.length-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]<target){
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    return -1;   
}
```

### 2.删除单链表中包含目标数据的节点

```java
public ListNode deleteTarget(ListNode head,int target){
    ListNode newHead=new ListNode(0);
    newHead.next=head;
    ListNode prev=newHead,cur=head;
    while(cur!=null){
        if(cur.val==target){
            prev.next=cur.next;
            cur=cur.next;
        }else{
            prev=prev.next;
            cur=cur.next;
        }
    }
    return newHead.next;
}
```





