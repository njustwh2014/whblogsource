---
title: 编程题汇总
date: 2020-03-13 21:05:04
tags: 
    - Java 
categories: 求职
---
## 二分查找

```java
/*
@nums 排序好的数组
@target
@return f返回目标下标 如果没有 返回-1
*/
public int binarySearch(int[] nums,int target){
    if(nums==null||nums.length==0){
        return -1;
    }
    int left=0,right=nums.length-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]<target){
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    return -1;   
}
```

## 删除单链表中包含目标数据的节点

```java
public ListNode deleteTarget(ListNode head,int target){
    ListNode newHead=new ListNode(0);
    newHead.next=head;
    ListNode prev=newHead,cur=head;
    while(cur!=null){
        if(cur.val==target){
            prev.next=cur.next;
            cur=cur.next;
        }else{
            prev=prev.next;
            cur=cur.next;
        }
    }
    return newHead.next;
}
```


## 迷宫传送门

```java
/*
1 0 -1 1
-2 0 -1 -3
2 2 0 0

-2:起点
-3:终点
-1:障碍物不能走

1和2 任意门，可以用也可以不用
*/

//存坐标
class Node{
    int x;
    int y;

    public Node(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "Node{" +
                "x=" + x +
                ", y=" + y +
                '}';
    }
}
//bfs
public int getMinSteps(int[][] matrix){

    //保存任意门坐标
    List<Node> door1=new ArrayList<>();//1：任意门
    List<Node> door2=new ArrayList<>();//2:任意门

    //任意门存储已经找到终点和起点
    Node start=new Node(0,0),end=new Node(0,0);
    for(int i=0;i<matrix.length;i++){
        for(int j=0;j<matrix[i].length;j++){
            if(matrix[i][j]==1){
                Node node=new Node(i,j);
                door1.add(node);
            }

            if(matrix[i][j]==2){
                Node node=new Node(i,j);
                door2.add(node);
            }

            if(matrix[i][j]==-2){
                start.x=i;
                start.y=j;
            }

            if(matrix[i][j]==-3){
                end.x=i;
                end.y=j;
            }
        }
    }


    Queue<Node> queue=new LinkedList<>();

    HashSet<String> hashSet=new HashSet<>();//访问过的点不重复

    //bfs
    int steps=0,size=1;
    queue.add(start);
    hashSet.add(start.toString());
    while(!queue.isEmpty()){
        Node cur=queue.poll();
        if(matrix[cur.x][cur.y]==-3){
            //找到终点
            return steps;
        }
        //添加下次到达的点
        if(matrix[cur.x][cur.y]==1){
            for(Node node:door1){
                if(!hashSet.contains(node.toString())){
                    hashSet.add(node.toString());
                    queue.add(node);
                }
            }
        }
        if(matrix[cur.x][cur.y]==2){
            for(Node node:door2){
                if(!hashSet.contains(node.toString())){
                    hashSet.add(node.toString());
                    queue.add(node);
                }
            }
        }
        if(validPosition(matrix,cur.x+1,cur.y)){
            Node node=new Node(cur.x+1,cur.y);
            if(!hashSet.contains(node.toString())){
                hashSet.add(node.toString());
                queue.add(node);
            }
        }

        if(validPosition(matrix,cur.x-1,cur.y)){
            Node node=new Node(cur.x-1,cur.y);
            if(!hashSet.contains(node.toString())){
                hashSet.add(node.toString());
                queue.add(node);
            }
        }

        if(validPosition(matrix,cur.x,cur.y+1)){
            Node node=new Node(cur.x,cur.y+1);
            if(!hashSet.contains(node.toString())){
                hashSet.add(node.toString());
                queue.add(node);
            }
        }
        if(validPosition(matrix,cur.x,cur.y+1)){
            Node node=new Node(cur.x,cur.y+1);
            if(!hashSet.contains(node.toString())){
                hashSet.add(node.toString());
                queue.add(node);
            }
        }

        size--;
        if(size==0){
            steps++;
            size=queue.size();
        }
    }
    return steps;
}

private boolean validPosition(int[][] matrix,int x,int y){
    if(x<0||x>=matrix.length||y<0||y>=matrix[0].length){
        return false;
    }
    return true;
}


```

## 求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199

```java
public static int getMaxMultiByDp(int x){
    String str=String.valueOf(x);
    int res=0;
    int nine=1;
    int num=0,bits=1;
    int[] nums=new int[str.length()];
    for(int i=str.length()-1;i>=0;i--){
        int cur=Integer.valueOf(str.charAt(i)-'0');
        if(i==str.length()-1){
            res=cur;
            nums[i]=cur;
        }else if(i==0&&cur==1){
            //处理首位为1
            if(nine>cur*res){
                res=nine;
                for(int j=i+1;j<nums.length;j++){
                    nums[j]=9;
                }
                nums[i]=0;
            }else{
                res=cur*res;
                nums[i]=cur;
            }
        } else{
            if((cur-1)*nine>cur*res){
                res=(cur-1)*nine;
                for(int j=i+1;j<nums.length;j++){
                    nums[j]=9;
                }
                nums[i]=cur-1;
            }else{
                res=cur*res;
                nums[i]=cur;
            }
        }
        nine=nine*9;
    }
    res=0;
    for(int i=0;i<nums.length;i++){
        res=res*10+nums[i];
    }
    return res;
}
```

