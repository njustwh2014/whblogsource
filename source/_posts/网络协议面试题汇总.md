---
title: 网络协议面试题汇总
date: 2020-03-13 20:53:35
tags: 
    - TCP
    - HTTP
categories: 求职
---

## Http协议

### Get和Post比较

[看这篇装逼文章](https://learnku.com/articles/25881)

+ Get发送一次数据包 Post发送两次数据包
  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
  - 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
+ GET在浏览器回退时是无害的，而POST会再次提交请求。
+ GET产生的URL地址可以被Bookmark，而POST不可以。
+ GET请求会被浏览器主动cache，而POST不会，除非手动设置。
+ GET请求只能进行url编码，而POST支持多种编码方式。
+ GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
+ GET请求在URL中传送的参数是有长度限制的，而POST么有。
+ 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
+ GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
+ GET参数通过URL传递，POST放在Request body中。

> Session和Cookie比较

session是存储在服务器端,cookie是存储在客户端的,所以安全来讲session的安全性要比cookie高,然后我们获取session里的信息是通过存放在**会话cookie**里的sessionid获取的。又由于session是存放在服务器的内存中,所以session里的东西不断增加会造成服务器的负担,所以会把很重要的信息存储在session中,而把一些次要东西存储在客户端的cookie里。

cookie确切的说分为两大类分为**会话cookie和持久化cookie**,会话cookie确切的说是存放在客户端浏览器的内存中,所以说他的生命周期和浏览器是一致的,浏览器关了会话cookie也就消失了,然而持久化cookie是存放在客户端硬盘中,而持久化cookie的生命周期就是我们在设置cookie时候设置的那个保存时间,然后我们考虑一问题当浏览器关闭时session会不会丢失,从上面叙述分析session的信息是通过sessionid获取的,而sessionid是存放在会话cookie当中的,当浏览器关闭的时候会话cookie消失所以我们的sessionid也就消失了,但是session的信息还存在服务器端,这时我们只是查不到所谓的session但它并不是不存在。那么,session在什么情况下丢失,就是在服务器关闭的时候,或者是sessio过期,再或者调用了invalidate()的或者是我们想要session中的某一条数据消失调用session.removeAttribute()方法,然后session在什么时候被创建呢,确切的说是通过调用session.getsession来创建,这就是session与cookie的区别。

> 常用HTTP的头部

头部 | 说明
---- | ----
Accept: text/html,image/* | 浏览器接受的数据类型
Accept-Charset: ISO-8859-1|浏览器接受的编码格式
Accept-Encoding: gzip,compress|浏览器接受的数据压缩格式
Accept-Language: en-us,zh-|浏览器接受的语言
Host: www.it315.org:80|（必须的）当前请求访问的目标地址（主机:端口）
If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT |浏览器最后的缓存时间
Referer: http://www.it315.org/index.jsp   |当前请求来自于哪里
User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) |浏览器类型
Cookie:name=eric|浏览器保存的cookie信息
Connection: close/Keep-Alive |浏览器跟服务器连接状态。close: 连接关闭  keep-alive：保存连接。
Date: Tue, 11 Jul 2000 18:23:51 GMT |请求发出的时间

### 常用的HTTP状态码

[参考文章](https://www.cnblogs.com/starof/p/5035119.html)

100 200 201 202 3xx 4xx 5xx

> HTTP1.0、1.1、2.0三个版本各自的特性

[参考文章](https://www.jianshu.com/p/52d86558ca57)

+ HTTP1.0与1.1区别
  - 缓存处理
  - 带宽优化及网络连接的使用
  - 错误通知的管理
  - 消息在网络中的发送
  - 互联网地址的维护
  - 安全性及完整性
+ HTTP2.0
  - 多路复用
  - 二进制分帧
  - 首部压缩
  - 服务器推送
  - 

### HTTPS中的SSL握手过程

[参考文章](https://www.jianshu.com/p/7158568e4867)

RSA/DH

[非对称加密-> 对称加密](https://zhuanlan.zhihu.com/p/43789231)

**由于RSA非对称加密以幂模运算的存在，导致其比ASE对称加密慢。**

### CSRF、XSS攻击，避免的方法

[参考文章](https://www.jianshu.com/p/64a413ada155)

## TCP

### TCP头部

记住常用部分占用多少字节

### 三次握手和四次挥手

+ 三次握手
  - 客户端发送请求报文给服务端，SYN=1 这个包序号为x 
  - 服务端给客户端发送确认报文ACK=1，SYN=1 这个包序号为y 确认号为x+1 此次握手表明 服务端可以接收客户端，但不确定客户端能否接收
  - 客户端给服务端发送确认报文 ACK=1 序号为x+1 确认号为y+1 此次握手告诉服务端，客户端也可以接收
+ 四次挥手
  - 客户端发送释放报文，FIN=1给服务端 此时客户端进入半关闭FIN-WAIT状态
  - 服务端返回确认报文ACK=1，此时服务端进入CLOSE-WAIT状态，接着服务端发送剩余的数据
  - 服务端发送完数据后发送释放报文给客户端，FIN=1，ACK=1
  - 客户端返回确认报文给服务端，后进入TIME-WAIT状态 经过2MSL时间后关闭，此时若再次接收服务端释放报文，则重发确认报文。

### 关于第三次握手的解释

我们可以假设没有第三次握手机制。当客户端向服务端发送请求建立报文A，由于网络延迟等原因导致超时后客户端重新发送请求建立连接报文B，请求建立连接报文B到达服务端后，服务端返回确认报文给客户端建立连接并传输数据。此时请求报文A也到达服务端，服务端会认为这是新的建立连接请求，并依旧返回确认报文给客户端，客户端没有建立连接需求，自然不会发送数据给服务端，而此时服务端会认为连接已经建立，会始终等待客户端发送数据，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。这样就浪费了很多服务器的资源。而如果有第三次握手，客户端不会返回确认，服务端收不到确认报文会认为客户端没有建立连接请求，从而不建立该连接。

### 第三次握手挥手失败的处理

第三次握手失败时，由于第二次握手时，服务端返回SYN+ACK给客户端，因此客户端进入成功建立连接状态，而此时服务端由于未收到客户端的ACK，这就要分为以下几种情况讨论：

+ 第一种情况是客户端发出的确认报文丢失，但是下一个数据包未丢失，此数据包中也含有ACK信息，服务端能够进入ESTABLISHED状态。
+ 第二种情况是客户端和服务端均没有发送数据，或者服务端想发送数据，但由于未接收到客户端ACK，从而不能发送数据，服务器端会有定时器，重新发送SYN+ACK数据包给客户端，客户端再次返回ACK数据包，则成功建立连接。
+ 第三种情况是一直不成功，一般是五次重传以后，服务器端会有超时设置，如果超时，服务端发送RTS报文，进入CLOSED状态，避免SYN洪泛攻击。

### SYN洪泛攻击

[康康](https://zhuanlan.zhihu.com/p/29539671)

SYN Flood（半开放攻击）是一种拒绝服务（DDoS）攻击，其目的是通过消耗所有可用的服务器资源使服务器不可用于合法流量。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器机器上的所有可用端口，导致目标设备根本不响应合法流量。

### 拥塞控制

[这个写的不错](https://juejin.im/entry/5b7fcd13f265da4372473199)

TCP 拥塞控制算法发展的过程中出现了如下几种不同的思路：

+ 基于**丢包**的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如 Reno、Cubic 等。

+ 基于**时延**的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如 Vegas、FastTCP 等。

+ 基于**链路容量**的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如 BBR。

+ 基于**学习**的拥塞控制：没有特定的拥塞信号，而是借助**评价函数**，基于训练数据，使用机器学习的方法形成一个控制策略，如 Remy。

**Reno算法：慢开始、拥塞避免、快重传、快恢复** 慢开始指数增长，到达慢开始阈值ssthresh时，进入拥塞避免，线性增长，如果出现超时，则进入重新慢开始，此时ssthresh变为当前cnwd的一半。如果出现丢包，则进入快重传阶段，直接进入拥塞避免，但ssthresh变为当前cnwd的一半。

**Vegas算法**：将时延 RTT 的增加作为网络出现拥塞的信号，RTT 增加，拥塞窗口减小，RTT 减小，拥塞窗口增加。

> 流量控制(零窗口含义、接受窗口的协商)

**什么是流量控制？流量控制的目的？**

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

**如何实现流量控制？**

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

**流量控制引发的死锁？怎么避免死锁的发生？**

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。

为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。


**拥塞控制作用于网络，防止大量数据进入网络导致阻塞，流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。**

### Nagle

[参考文章](https://blog.csdn.net/ce123_zhouwei/article/details/9050797)

### TCP与UDP的区别

+ 1、基于连接与无连接； why？
+ 2、对系统资源的要求（TCP较多，UDP少）； why?
+ 3、UDP程序结构较简单； why?
+ 4、流模式与数据报模式 ； why?
+ 5、TCP保证数据正确性，UDP可能丢包； why?
+ 6、TCP保证数据顺序，UDP不保证。why?

## 描述数据从网卡至内核空间最后至用户空间的过程

数据通过网线进入网卡后，进行模数转换写入网卡缓存，通过DMA写入计算机内存，一个内核线程根据TCP协议进行拆包，最后将数据写入每个socket对应的sync/accept队列中，供应用程序使用(应用程序需要进行组包操作，对应着分包操作)。


## url到获取页面过程

在浏览器中输入一个网址，首先要做的就是域名的解析，也就是域名->ip的解析，依次查看了浏览器缓存，系统缓存，hosts文件，路由器缓存，递归搜索根域名服务器，直到找到最终的ip地址。

然后就是TCP协议的三次握手建立连接，过程我们已经阐述了。由浏览器发送一个HTTP请求；经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器；服务器处理该HTTP请求，返回一个HTML文件；浏览器解析该HTML文件，并且渲染显示在浏览器端。

这里，我们可以来具体阐述下HTTP协议和TCP协议的关系与区别。

## 介绍TCP/IP头，其中哪些首部涉及滑动窗口，以及拥塞控制


## http与https的区别

## CDN的关键技术

[参考连接](https://blog.csdn.net/moakun/article/details/80690536)

CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理。

+ 1.用户向浏览器输入www.web.com这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；
+ 2.网站的DNS域名解析器设置了CNAME，指向了www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统；
+ 3.智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；
+ 4.用户向该IP节点（CDN服务器）发出请求；
+ 5.由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；
+ 6.请求结果发给用户。

